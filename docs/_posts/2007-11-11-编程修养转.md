---
title: "编程修养(转)"
date: 2007-11-11
author: pengjianqing
categories: ['Tech']
---

编程修养(转)

文章来源：[http://www.csdn.net](http://www.csdn.net)
文章作者：haoel

编程修养

什么是好的程序员？是不是懂得很多技术细节？还是懂底层编程？还是编程速度比较快？我觉得都不是。对于一些技术细节来说和底层的技术，只要看帮助，查资料就能找到，对于速度快，只要编得多也就熟能生巧了。
我认为好的程序员应该有以下几方面的素质：
1、有专研精神，勤学善问、举一反三。
2、积极向上的态度，有创造性思维。
3、与人积极交流沟通的能力，有团队精神。
4、谦虚谨慎，戒骄戒燥。
5、写出的代码质量高。包括：代码的稳定、易读、规范、易维护、专业。
这些都是程序员的修养，这里我想谈谈“编程修养”，也就是上述中的第5点。我觉得，如果我要了解一个作者，我会看他所写的小说，如果我要了解一个画家，我会看他所画的图画，如果我要了解一个工人，我会看他所做出来的产品，同样，如果我要了解一个程序员，我想首先我最想看的就是他的程序代码，程序代码可以看出一个程序员的素质和修养，程序就像一个作品，有素质有修养的程序员的作品必然是一图精美的图画，一首美妙的歌曲，一本赏心悦目的小说。
我看过许多程序，没有注释，没有缩进，胡乱命名的变量名，等等，等等，我把这种人统称为没有修养的程序，这种程序员，是在做创造性的工作吗？不，完全就是在搞破坏，他们与其说是在编程，还不如说是在对源程序进行“加密”，这种程序员，见一个就应该开除一个，因为他编的程序所创造的价值，远远小于需要在上面进行维护的价值。
程序员应该有程序员的修养，那怕再累，再没时间，也要对自己的程序负责。我宁可要那种动作慢，技术一般，但有良好的写程序风格的程序员，也不要那种技术强、动作快的“搞破坏”的程序员。有句话叫“字如其人”，我想从程序上也能看出一个程序员的优劣。因为，程序是程序员的作品，作品的好坏直截关系到程序员的声誉和素质。而“修养”好的程序员一定能做出好的程序和软件。
有个成语叫“独具匠心”，意思是做什么都要做得很专业，很用心，如果你要做一个“匠”，也就是造诣高深的人，那么，从一件很简单的作品上就能看出你有没有“匠”的特性，我觉得做一个程序员不难，但要做一个“程序匠”就不简单了。编程序很简单，但编出有质量的程序就难了。
我在这里不讨论过深的技术，我只想在一些容易让人忽略的东西上说一说，虽然这些东西可能很细微，但如果你不注意这些细微之处的话，那么他将会极大的影响你的整个软件质量，以及整个软件程的实施，所谓“千里之堤，毁于蚁穴”。
“细微之处见真功”，真正能体现一个程序的功底恰恰在这些细微之处。
这就是程序员的--编程修养。我总结了在用C/C++语言（主要是C语言）进行程序写作上的三十二个“修养”，通过这些，你可以写出质量高的程序，同时也会让看你程序的人渍渍称道，那些看过你程序的人一定会说：“这个人的编程修养不错”。
------------------------

01、版权和版本
02、缩进、空格、换行、空行、对齐
03、程序注释
04、函数的[in][out]参数
05、对系统调用的返回进行判断
06、if 语句对出错的处理
07、头文件中的#ifndef
08、在堆上分配内存
09、变量的初始化
10、h和c文件的使用
11、出错信息的处理
12、常用函数和循环语句中的被计算量
13、函数名和变量名的命名
14、函数的传值和传指针
15、修改别人程序的修养
16、把相同或近乎相同的代码形成函数和宏
17、表达式中的括号
18、函数参数中的const
19、函数的参数个数
20、函数的返回类型，不要省略
21、goto语句的使用
22、宏的使用
23、static的使用
24、函数中的代码尺寸
25、typedef的使用
26、为常量声明宏
27、不要为宏定义加分号
28、||和&&的语句执行顺序
29、尽量用for而不是while做循环
30、请sizeof类型而不是变量
31、不要忽略Warning
32、书写Debug版和Release版的程序
------------------------

1、版权和版本
-------
好的程序员会给自己的每个函数，每个文件，都注上版权和版本。
对于C/C++的文件，文件头应该有类似这样的注释：
/************************************************************************
*
*　 文件名：network.c
*
*　 文件描述：网络通讯函数集
*
*　 创建人： Hao Chen, 2003年2月3日
*
*　 版本号：1.0
*
*　 修改记录：
*
************************************************************************/
而对于函数来说，应该也有类似于这样的注释：
/*================================================================
*
* 函 数 名：XXX
*
* 参　　数：
*
*　　　　type name [IN] : descripts
*
* 功能描述:
*
*　　　　..............
*
* 返 回 值：成功TRUE，失败FALSE
*
* 抛出异常：
*
* 作　　者：ChenHao 2003/4/2
*
================================================================*/
这样的描述可以让人对一个函数，一个文件有一个总体的认识，对代码的易读性和易维护性有很大的好处。这是好的作品产生的开始。

2、缩进、空格、换行、空行、对齐
----------------
i) 缩进应该是每个程序都会做的，只要学程序过程序就应该知道这个，但是我仍然看过不缩进的程序，或是乱缩进的程序，如果你的公司还有写程序不缩进的程序员，请毫不犹豫的开除他吧，并以破坏源码罪起诉他，还要他赔偿读过他程序的人的精神损失费。缩进，这是不成文规矩，我再重提一下吧，一个缩进一般是一个TAB 键或是4个空格。（最好用TAB键）
ii) 空格。空格能给程序代来什么损失吗？没有，有效的利用空格可以让你的程序读进来更加赏心悦目。而不一堆表达式挤在一起。看看下面的代码：
ha=(ha*128+*key++)%tabPtr->size;
ha = ( ha * 128 + *key++ ) % tabPtr->size;
有空格和没有空格的感觉不一样吧。一般来说，语句中要在各个操作符间加空格，函数调用时，要以各个参数间加空格。如下面这种加空格的和不加的：

if ((hProc=OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid))==NULL){
}
if ( ( hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid) ) == NULL ){
}
iii) 换行。不要把语句都写在一行上，这样很不好。如：
for(i=0;i´9´)&&(a´z´)) break;

我拷，这种即无空格，又无换行的程序在写什么啊？加上空格和换行吧。

for ( i=0; i ´9´ ) &&
( a  ´z´ ) ) {
break;
}
}
好多了吧？有时候，函数参数多的时候，最好也换行，如：
CreateProcess(
NULL,
cmdbuf,
NULL,
NULL,
bInhH,
dwCrtFlags,
envbuf,
NULL,
&siStartInfo,
&prInfo
);
条件语句也应该在必要时换行：

if ( ch >= ´0´ || ch = ´a´ || ch = ´A´ || ch name;
}
不！请不要这样做。
你应该先判断一下传进来的那个指针是不是为空。如果传进来的指针为空的话，那么，你的一个大的系统就会因为这一个小的函数而崩溃。一种更好的技术是使用断言（assert），这里我就不多说这些技术细节了。当然，如果是在C++中，引用要比指针好得多，但你也需要对各个参数进行检查。
写有参数的函数时，首要工作，就是要对传进来的所有参数进行合法性检查。而对于传出的参数也应该进行检查，这个动作当然应该在函数的外部，也就是说，调用完一个函数后，应该对其传出的值进行检查。
当然，检查会浪费一点时间，但为了整个系统不至于出现“非法操作”或是“Core Dump”的系统级的错误，多花这点时间还是很值得的。

5、对系统调用的返回进行判断
--------------
继续上一条，对于一些系统调用，比如打开文件，我经常看到，许多程序员对fopen返回的指针不做任何判断，就直接使用了。然后发现文件的内容怎么也读出不，或是怎么也写不进去。还是判断一下吧：
fp = fopen("log.txt", "a");
if ( fp == NULL ){
printf("Error: open file errorn");
return FALSE;
}
其它还有许多啦，比如：socket返回的socket号，malloc返回的内存。请对这些系统调用返回的东西进行判断。

6、if 语句对出错的处理
-----------
我看见你说了，这有什么好说的。还是先看一段程序代码吧。
if ( ch >= ´0´ && ch  ´9´ ){
/* 输出错误信息 */
printf("error ......n");
return ( FALSE );
}

/* 正常处理代码 */
......

这样的结构，不是很清楚吗？突出了错误的条件，让别人在使用你的函数的时候，第一眼就能看到不合法的条件，于是就会更下意识的避免。

7、头文件中的#ifndef
----------
千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。
还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：
#ifndef　
#define 

......
......

#endif

在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h
#ifndef _STDIO_H_
#define _STDIO_H_

......

#endif

（BTW：预编译有多很有用的功能。你会用预编译吗？）
8、在堆上分配内存
---------
可能许多人对内存分配上的“栈 stack”和“堆 heap”还不是很明白。包括一些科班出身的人也不明白这两个概念。我不想过多的说这两个东西。简单的来讲，stack上分配的内存系统自动释放， heap上分配的内存，系统不释放，哪怕程序退出，那一块内存还是在那里。stack一般是静态分配内存，heap上一般是动态分配内存。
由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己释放。用free释放，不然就是术语--“内存泄露”（或是“内存漏洞”）-- Memory Leak。于是，系统的可分配内存会随malloc越来越少，直到系统崩溃。还是来看看“栈内存”和“堆内存”的差别吧。
栈内存分配
-----
char*
AllocStrFromStack()
{
char pstr[100];
return pstr;
}

堆内存分配
-----
char*
AllocStrFromHeap(int len)
{
char *pstr;

if ( len  ErrCode,　ServerListener -> ServLisner，UserAccount -> UsrAcct 等。
5) 为了避免全局函数和变量名字冲突，可以加上一些前缀，一般以模块简称做为前缀。
6) 全局变量统一加一个前缀或是后缀，让人一看到这个变量就知道是全局的。
7) 用匈牙利命名法命名函数参数，局部变量。但还是要坚持“望文生意”的原则。
![Cool](images/smiles/icon_cool.gif) 与标准库（如：STL）或开发库（如：MFC）的命名风格保持一致。

14、函数的传值和传指针
------------
向函数传参数时，一般而言，传入非const的指针时，就表示，在函数中要修改这个指针把指内存中的数据。如果是传值，那么无论在函数内部怎么修改这个值，也影响不到传过来的值，因为传值是只内存拷贝。
什么？你说这个特性你明白了，好吧，让我们看看下面的这个例程：
void
GetVersion(char* pStr)
{
pStr = malloc(10);
strcpy ( pStr, "2.0" );
}
main()
{
char* ver = NULL;
GetVersion ( ver );
...
...
free ( ver );
}
我保证，类似这样的问题是一个新手最容易犯的错误。程序中妄图通过函数GetVersion给指针ver分配空间，但这种方法根本没有什么作用，原因就是--这是传值，不是传指针。你或许会和我争论，我分明传的时指针啊？再仔细看看，其实，你传的是指针其实是在传值。

15、修改别人程序的修养
-----------
当你维护别人的程序时，请不要非常主观臆断的把已有的程序删除或是修改。我经常看到有的程序员直接在别人的程序上修改表达式或是语句。修改别人的程序时，请不要删除别人的程序，如果你觉得别人的程序有所不妥，请注释掉，然后添加自己的处理程序，必竟，你不可能100%的知道别人的意图，所以为了可以恢复，请不依赖于CVS或是SourceSafe这种版本控制软件，还是要在源码上给别人看到你修改程序的意图和步骤。这是程序维护时，一个有修养的程序员所应该做的。
如下所示，这就是一种比较好的修改方法：
/*
* ----- commented by haoel 2003/04/12 ------
*
*　 char* p = ( char* ) malloc( 10 );
*　 memset( p, 0, 10 );
*/

/* ------ Added by haoel　 2003/04/12 ----- */
char* p = ( char* )calloc( 10, sizeof char );
/* ---------------------------------------- */
...
当然，这种方法是在软件维护时使用的，这样的方法，可以让再维护的人很容易知道以前的代码更改的动作和意图，而且这也是对原作者的一种尊敬。
以“注释 - 添加”方式修改别人的程序，要好于直接删除别人的程序。
16、把相同或近乎相同的代码形成函数和宏
---------------------
有人说，最好的程序员，就是最喜欢“偷懒”的程序，其中不无道理。
如果你有一些程序的代码片段很相似，或直接就是一样的，请把他们放在一个函数中。而如果这段代码不多，而且会被经常使用，你还想避免函数调用的开销，那么就把他写成宏吧。
千万不要让同一份代码或是功能相似的代码在多个地方存在，不然如果功能一变，你就要修改好几处地方，这种会给维护带来巨大的麻烦，所以，做到“一改百改”，还是要形成函数或是宏。

17、表达式中的括号
---------
如果一个比较复杂的表达式中，你并不是很清楚各个操作符的忧先级，即使是你很清楚优先级，也请加上括号，不然，别人或是自己下一次读程序时，一不小心就看走眼理解错了，为了避免这种“误解”，还有让自己的程序更为清淅，还是加上括号吧。
比如，对一个结构的成员取地址：
GetUserAge( &( UserInfo->age ) );
虽然，&UserInfo->age中，->操作符的优先级最高，但加上一个括号，会让人一眼就看明白你的代码是什么意思。
再比如，一个很长的条件判断：
if ( ( ch[0] >= ´0´ || ch[0] = ´a´ || ch[1] = ´A´ || ch[2] b?a:b
当我们这样使用宏时，没有什么问题： MAX( num1, num2 ); 因为宏展开后变成 num1>num2?num1:num2；。但是，如果是这样调用的，MAX( 17+32, 25+21 ); 呢，编译时出现错误，原因是，宏展开后变成：17+32>25+21?17+32:25+21，哇，这是什么啊？
所以，宏在使用时，参数一定要加上括号，上述的那个例子改成如下所示就能解决问题了。
#define　MAX( (a), (b) )　　 (a)>(b)?(a)![Sad](images/smiles/icon_sad.gif)b)

即使是这样，也不这个宏也还是有Bug，因为如果我这样调用 MAX(i++, j++); ，经过这个宏以后，i和j都被累加了两次，这绝不是我们想要的。

所以，在宏的使用上还是要谨慎考虑，因为宏展开是的结果是很难让人预料的。而且虽然，宏的执行很快（因为没有函数调用的开销），但宏会让源代码澎涨，使目标文件尺寸变大，（如：一个50行的宏，程序中有1000个地方用到，宏展开后会很不得了），相反不能让程序执行得更快（因为执行文件变大，运行时系统换页频繁）。
因此，在决定是用函数，还是用宏时得要小心。

23、static的使用
--------
static关键字，表示了“静态”，一般来说，他会被经常用于变量和函数。一个static的变量，其实就是全局变量，只不过他是有作用域的全局变量。比如一个函数中的static变量：
char*
getConsumerName()
{
static int cnt = 0;

....
cnt++;
....
}
cnt变量的值会跟随着函数的调用次而递增，函数退出后，cnt的值还存在，只是cnt只能在函数中才能被访问。而cnt的内存也只会在函数第一次被调用时才会被分配和初始化，以后每次进入函数，都不为static分配了，而直接使用上一次的值。
对于一些被经常调用的函数内的常量，最好也声明成static（参见第12条）
但static的最多的用处却不在这里，其最大的作用的控制访问，在C中如果一个函数或是一个全局变量被声明为static，那么，这个函数和这个全局变量，将只能在这个C文件中被访问，如果别的C文件中调用这个C文件中的函数，或是使用其中的全局（用extern关键字），将会发生链接时错误。这个特性可以用于数据和程序保密。

24、函数中的代码尺寸
----------
一个函数完成一个具体的功能，一般来说，一个函数中的代码最好不要超过600行左右，越少越好，最好的函数一般在100行以内，300行左右的孙函数就差不多了。有证据表明，一个函数中的代码如果超过500行，就会有和别的函数相同或是相近的代码，也就是说，就可以再写另一个函数。
另外，函数一般是完成一个特定的功能，千万忌讳在一个函数中做许多件不同的事。函数的功能越单一越好，一方面有利于函数的易读性，另一方面更有利于代码的维护和重用，功能越单一表示这个函数就越可能给更多的程序提供服务，也就是说共性就越多。
虽然函数的调用会有一定的开销，但比起软件后期维护来说，增加一些运行时的开销而换来更好的可维护性和代码重用性，是很值得的一件事。

25、typedef的使用
---------
typedef是一个给类型起别名的关键字。不要小看了它，它对于你代码的维护会有很好的作用。比如C中没有bool，于是在一个软件中，一些程序员使用int，一些程序员使用short，会比较混乱，最好就是用一个typedef来定义，如：
typedef char bool;

一般来说，一个C的工程中一定要做一些这方面的工作，因为你会涉及到跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以让你最有效的维护你的代码，如下所示：
#ifdef SOLARIS2_5
typedef boolean_t　　 BOOL_T;
#else
typedef int　　　　　 BOOL_T;
#endif

typedef short　　　　　 INT16_T;
typedef unsigned short　UINT16_T;
typedef int　　　　　　 INT32_T;
typedef unsigned int　　UINT32_T;

#ifdef WIN32
typedef _int64　　　　INT64_T;
#else
typedef long long　　 INT64_T;
#endif

typedef float　　　　　 FLOAT32_T;
typedef char*　　　　　 STRING_T;
typedef unsigned char　 BYTE_T;
typedef time_t　　　　　TIME_T;
typedef INT32_T　　　　 PID_T;

使用typedef的其它规范是，在结构和函数指针时，也最好用typedef，这也有利于程序的易读和可维护性。如：
typedef struct _hostinfo {
HOSTID_T　 host;
INT32_T　　hostId;
STRING_T　 hostType;
STRING_T　 hostModel;
FLOAT32_T　cpuFactor;
INT32_T　　numCPUs;
INT32_T　　nDisks;
INT32_T　　memory;
INT32_T　　swap;
} HostInfo;

typedef INT32_T (*RsrcReqHandler)(
void *info,
JobArray *jobs,
AllocInfo *allocInfo,
AllocList *allocList);
C++中这样也是很让人易读的：
typedef CArray HostInfoArray;
于是，当我们用其定义变量时，会显得十分易读。如：
HostInfo* phinfo;
RsrcReqHandler* pRsrcHand;
这种方式的易读性，在函数的参数中十分明显。
关键是在程序种使用typedef后，几乎所有的程序中的类型声明都显得那么简洁和清淅，而且易于维护，这才是typedef的关键。

26、为常量声明宏
--------
最好不要在程序中出现数字式的“硬编码”，如：
int user[120];

为这个120声明一个宏吧。为所有出现在程序中的这样的常量都声明一个宏吧。比如TimeOut的时间，最大的用户数量，还有其它，只要是常量就应该声明成宏。如果，突然在程序中出现下面一段代码，
for ( i=0; i0 ) { PRINT_LINE; }

都不要在最后加上分号，当我们在程序中使用时，为之加上分号，
main()
{
char *p = LINE;
PRINT_LINE;
}
这一点非常符合习惯，而且，如果忘加了分号，编译器给出的错误提示，也会让我们很容易看懂的。
28、||和&&的语句执行顺序
------------
条件语句中的这两个“与”和“或”操作符一定要小心，它们的表现可能和你想像的不一样，这里条件语句中的有些行为需要和说一下：
express1 || express2

先执行表达式express1如果为“真”，express2将不被执行，express2仅在express1为“假”时才被执行。因为第一个表达式为真了，整个表达式都为真，所以没有必要再去执行第二个表达式了。
express1 && express2
先执行表达式express1如果为“假”，express2将不被执行，express2仅在express1为“真”时才被执行。因为第一个表达式为假了，整个表达式都为假了，所以没有必要再去执行第二个表达式了。

于是，他并不是你所想像的所有的表达式都会去执行，这点一定要明白，不然你的程序会出现一些莫明的运行时错误。
例如，下面的程序：

if ( sum > 100 &&
( ( fp=fopen( filename,"a" ) ) != NULL )　 {

fprintf(fp, "Warring: it beyond one hundredn");
......
}

fprintf( fp, " sum is %id n", sum );
fclose( fp );
本来的意图是，如果sum > 100 ，向文件中写一条出错信息，为了方便，把两个条件判断写在一起，于是，如果sumnext;
}
当while的语句块变大后，你的程序将很难读，用for就好得多：
for ( p=pHead;　p; p=p->next ){
..
}
一眼就知道这个循环的开始条件，结束条件，和循环的推进。大约就能明白这个循环要做个什么事？而且，程序维护进来很容易，不必像while一样，在一个编辑器中上上下下的捣腾。

30、请sizeof类型而不是变量
-------------
许多程序员在使用sizeof中，喜欢sizeof变量名，例如：
int score[100];
char filename[20];
struct UserInfo usr[100];
在sizeof这三个的变量名时，都会返回正确的结果，于是许多程序员就开始sizeof变量名。这个习惯很虽然没有什么不好，但我还是建议sizeof类型。
我看到过这个的程序：
pScore = (int*) malloc( SUBJECT_CNT );
memset( pScore, 0, sizeof(pScore) );
...

此时，sizeof(pScore)返回的就是4（指针的长度），不会是整个数组，于是，memset就不能对这块内存进行初始化。为了程序的易读和易维护，我强烈建议使用类型而不是变量，如：
对于score：　　 sizeof(int) * 100　 /* 100个int */
对于filename：　sizeof(char) * 20　 /* 20个char */
对于usr：　　　 sizeof(struct UserInfo) * 100　 /* 100个UserInfo */
这样的代码是不是很易读？一眼看上去就知道什么意思了。

另外一点，sizeof一般用于分配内存，这个特性特别在多维数组时，就能体现出其优点了。如，给一个字符串数组分配内存，
/*
* 分配一个有20个字符串，
* 每个字符串长100的内存
*/
char* *p;
/*
* 错误的分配方法
*/
p = (char**)calloc( 20*100, sizeof(char) );

/*
* 正确的分配方法
*/
p = (char**) calloc ( 20, sizeof(char*) );
for ( i=0; i<20; i++){
/*p = (char*) calloc ( 100, sizeof(char) );*/
p = (char*) calloc ( 100, sizeof(char) );
}
（注：上述语句被注释掉的是原来的，是错误的，由dasherest朋友指正，谢谢）
为了代码的易读，省去了一些判断，请注意这两种分配的方法，有本质上的差别。

31、不要忽略Warning
----------
对于一些编译时的警告信息，请不要忽视它们。虽然，这些Warning不会妨碍目标代码的生成，但这并不意味着你的程序就是好的。必竟，并不是编译成功的程序才是正确的，编译成功只是万里长征的第一步，后面还有大风大浪在等着你。从编译程序开始，不但要改正每个error，还要修正每个warning。这是一个有修养的程序员该做的事。
一般来说，一面的一些警告信息是常见的：
1）声明了未使用的变量。（虽然编译器不会编译这种变量，但还是把它从源程序中注释或是删除吧）
2）使用了隐晦声明的函数。（也许这个函数在别的C文件中，编译时会出现这种警告，你应该这使用之前使用extern关键字声明这个函数）
3）没有转换一个指针。（例如malloc返回的指针是void的，你没有把之转成你实际类型而报警，还是手动的在之前明显的转换一下吧）
4）类型向下转换。（例如：float f = 2.0; 这种语句是会报警告的，编译会告诉你正试图把一个double转成float，你正在阉割一个变量，你真的要这样做吗？还是在2.0后面加个f吧，不然，2.0就是一个double，而不是float了）

不管怎么说，编译器的Warning不要小视，最好不要忽略，一个程序都做得出来，何况几个小小的Warning呢？

32、书写Debug版和Release版的程序
----------------
程序在开发过程中必然有许多程序员加的调试信息。我见过许多项目组，当程序开发结束时，发动群众删除程序中的调试信息，何必呢？为什么不像VC++那样建立两个版本的目标代码？一个是debug版本的，一个是Release版的。那些调试信息是那么的宝贵，在日后的维护过程中也是很宝贵的东西，怎么能说删除就删除呢？
利用预编译技术吧，如下所示声明调试函数：
#ifdef DEBUG
void TRACE(char* fmt, ...)
{
......
}
#else
#define TRACE(char* fmt, ...)
#endif
于是，让所有的程序都用TRACE输出调试信息，只需要在在编译时加上一个参数“-DDEBUG”，如：
cc -DDEBUG -o target target.c
于是，预编译器发现DEBUG变量被定义了，就会使用TRACE函数。而如果要发布给用户了，那么只需要把取消“-DDEBUG”的参数，于是所有用到 TRACE宏，这个宏什么都没有，所以源程序中的所有TRACE语言全部被替换成了空。一举两得，一箭双雕，何乐而不为呢？
顺便提一下，两个很有用的系统宏，一个是“__FILE__”，一个是“__LINE__”，分别表示，所在的源文件和行号，当你调试信息或是输出错误时，可以使用这两个宏，让你一眼就能看出你的错误，出现在哪个文件的第几行中。这对于用C/C++做的大工程非常的管用。

综上所述32条，都是为了三大目的--
1、程序代码的易读性。
2、程序代码的可维护性，
3、程序代码的稳定可靠性。

有修养的程序员，就应该要学会写出这样的代码！这是任何一个想做编程高手所必需面对的细小的问题，编程高手不仅技术要强，基础要好，而且最重要的是要有“修养”！
好的软件产品绝不仅仅是技术，而更多的是整个软件的易维护和可靠性。
软件的维护有大量的工作量花在代码的维护上，软件的Upgrade，也有大量的工作花在代码的组织上，所以好的代码，清淅的，易读的代码，将给大大减少软件的维护和升级成本。